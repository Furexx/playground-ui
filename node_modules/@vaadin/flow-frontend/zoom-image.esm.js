/**
 * ZoomImage (@rocketbase/zoom-image v0.0.0)
 * Javascript component for partial zooming of images
 * https://github.com/rocketbase-io/image-zoom#readme
 * (c) 2020 Rocketbase Team <team@rocketbase.io>
 * @license MIT
 */
function normalizeOptions({ factor = 2, scale = 200, hide = true, position = "cursor", shape = position === "cursor" ? "circle" : "square", offset = [-scale / 2, -scale / 2], viewportClass = "rocket-zoom-image-viewport", zoomClass = "rocket-zoom-image-zoom", placeAt } = {}) {
    return { factor, scale, shape, position, offset, hide, viewportClass, zoomClass, placeAt };
}

function resolve(el) {
    if (typeof el === "string")
        el = document.querySelector(el);
    if (!el)
        throw new Error("No elements provided or no element matching selector!");
    return el;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
}

function assign(target, values) {
    for (const key of Object.keys(values)) {
        target[key] = values[key];
    }
    return target;
}

function Bound(proto, key, desc) {
    const orig = desc.value;
    desc.get = function () {
        Object.defineProperty(this, key, { value: orig.bind(this), enumerable: false, configurable: true, writable: false });
        return this[key];
    };
    delete desc.value;
    delete desc.writable;
}

function classes(cls = []) {
    return typeof cls === "string" ? cls.split(/\s+/g) : cls;
}
function addClasses(el, cls) {
    el.classList.add(...classes(cls));
}

class View {
    constructor(reference, options) {
        this.reference = reference;
        this.options = options;
        const { onMouseMove, onMouseEnter, onMouseLeave } = this;
        if (options.position === "cursor")
            reference.addEventListener("mousemove", onMouseMove, { passive: true });
        if (options.hide) {
            reference.addEventListener("mouseenter", onMouseEnter);
            reference.addEventListener("mouseleave", onMouseLeave);
        }
        else {
            this.setVisible(true);
            this.updateDimensions();
        }
    }
    setVisible(visible) {
        this.element.style.opacity = visible ? "1" : "0";
    }
    get element() {
        var _a;
        return (_a = this.el) !== null && _a !== void 0 ? _a : (this.el = this.createView());
    }
    createView() {
        const { reference, options } = this;
        const el = document.createElement("div");
        const style = el.style;
        const container = options.placeAt ? resolve(options.placeAt) : reference.parentElement;
        container === null || container === void 0 ? void 0 : container.appendChild(el);
        assign(style, {
            position: "absolute",
            pointerEvents: "none",
            overflow: "hidden",
            boxSizing: "border-box",
            cursor: "none",
            transition: "opacity .2s ease-in-out"
        });
        addClasses(el, options.viewportClass);
        return el;
    }
    updateDimensions(el = this.element) {
        const { reference, options } = this;
        const { shape, scale, position, offset } = options;
        const { offsetTop, offsetLeft, clientWidth, clientHeight } = reference;
        if (position === "cover")
            assign(el.style, {
                left: `${offsetLeft}px`,
                top: `${offsetTop}px`,
                width: `${clientWidth}px`,
                height: `${clientHeight}px`
            });
        if (position === "cursor")
            assign(el.style, {
                width: `${scale}px`,
                height: `${scale}px`,
                maxWidth: `${scale}px`,
                maxHeight: `${scale}px`,
                willChange: "top, left",
                transform: `translate(${offset.map(it => `${it}px`).join(",")})`
            });
        if (shape === "circle")
            el.style.borderRadius = "100000px";
    }
    updatePosition(ev, el = this.element) {
        if (this.options.position !== "cursor")
            return;
        const { offsetX, offsetY } = ev;
        const { offsetTop, offsetLeft } = this.reference;
        const { style } = el;
        style.top = `${offsetY + offsetTop}px`;
        style.left = `${offsetX + offsetLeft}px`;
    }
    attachZoom(el) {
        this.element.appendChild(el);
    }
    detachZoom(el) {
        this.element.removeChild(el);
    }
    onMouseMove(ev) {
        this.updatePosition(ev);
    }
    onMouseEnter(ev) {
        this.updateDimensions();
        this.updatePosition(ev);
        if (this.options.hide)
            this.setVisible(true);
    }
    onMouseLeave(ev) {
        if (this.options.hide)
            this.setVisible(false);
    }
    destroy() {
        const { reference, onMouseMove, onMouseEnter, onMouseLeave } = this;
        reference.removeEventListener("mousemove", onMouseMove);
        reference.removeEventListener("mouseenter", onMouseEnter);
        reference.removeEventListener("mouseleave", onMouseLeave);
        delete this.el;
        // @ts-expected-error
        delete this.reference;
    }
}
__decorate([
    Bound,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], View.prototype, "onMouseMove", null);
__decorate([
    Bound,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], View.prototype, "onMouseEnter", null);
__decorate([
    Bound,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], View.prototype, "onMouseLeave", null);

class Zoom {
    constructor(reference, view, options) {
        this.reference = reference;
        this.view = view;
        this.options = options;
        reference.addEventListener("mousemove", this.onMouseMove, { passive: true });
    }
    get element() {
        var _a;
        return (_a = this.el) !== null && _a !== void 0 ? _a : (this.el = this.createZoom());
    }
    get viewportDimensions() {
        const { clientWidth: width, clientHeight: height } = this.view.element;
        return { width, height };
    }
    getCssDimensions(el) {
        const { width, height } = getComputedStyle(el);
        return { width, height };
    }
    getOffsetFactor(ev) {
        const { clientWidth, clientHeight } = this.reference;
        const { offsetX, offsetY } = ev;
        const x = -offsetX / clientWidth;
        const y = -offsetY / clientHeight;
        return { x, y };
    }
    createZoom() {
        const { view, options, reference } = this;
        const { factor, zoomClass } = options;
        const image = document.createElement("img");
        const { width, height } = this.getCssDimensions(reference);
        image.src = reference.src;
        const { style } = image;
        assign(style, {
            transform: `scale(${factor})`,
            transformOrigin: "0 0",
            position: "absolute",
            width,
            height,
            willChange: "top, left",
            maxWidth: "unset"
        });
        addClasses(image, zoomClass);
        view.attachZoom(image);
        return image;
    }
    onMouseMove(ev) {
        const { x, y } = this.getOffsetFactor(ev);
        const { width, height } = this.viewportDimensions;
        const { element, options } = this;
        element.style.transform = `translate(${width / 2}px, ${height / 2}px) scale(${options.factor}) translate(${x * 100}%, ${y * 100}%)`;
    }
    destroy() {
        this.reference.removeEventListener("mousemove", this.onMouseMove);
        if (this.el)
            this.view.detachZoom(this.el);
        delete this.el;
        // @ts-expected-error
        delete this.reference;
        // @ts-expected-error
        delete this.view;
    }
}
__decorate([
    Bound,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [MouseEvent]),
    __metadata("design:returntype", void 0)
], Zoom.prototype, "onMouseMove", null);

class ZoomImage {
    constructor(reference, options) {
        this.reference = reference;
        this.options = options;
        this.create();
    }
    setOptions(options) {
        this.options = normalizeOptions(options);
        this.destroy();
        this.create();
    }
    create() {
        const { reference, options } = this;
        const view = this.view = new View(reference, options);
        this.zoom = new Zoom(reference, view, options);
    }
    destroy() {
        var _a, _b;
        (_a = this.zoom) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.view) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}

function attach(el, zoom) {
    return el.__zoom = zoom;
}
function detach(el) {
    delete el.__zoom;
}
function get(el) {
    return resolve(el).__zoom;
}
function has(el) {
    return !!get(el);
}
function create(el, options) {
    el = resolve(el);
    if (has(el))
        delete el.__zoom;
    return attach(el, new ZoomImage(el, normalizeOptions(options)));
}

export { ZoomImage, attach, create, detach, get, has };
//# sourceMappingURL=zoom-image.esm.js.map
