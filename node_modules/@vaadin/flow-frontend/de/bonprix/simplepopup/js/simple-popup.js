import {html, LitElement} from 'lit-element';
import {OverlayElement} from "@vaadin/vaadin-overlay";
import {css, registerStyles} from '@vaadin/vaadin-themable-mixin/register-styles.js';

const positions = {
    TOP: 'top',
    BOTTOM: 'bottom',
    LEFT: 'left',
    RIGHT: 'right',
    BOTTOM_RIGHT: 'bottomRight'
}

class SimplePopup extends LitElement {

    render() {
        return html`
                <slot name = "targetElement" id="target"></slot>
                <simple-popup-overlay 
                modeless
                id="overlay" 
                ?opened="${this.opened}"
                >
                <slot></slot>
                </simple-popup-overlay>
            `;
    }

    constructor() {
        super();
        this.opened = false;
        this.openOnClick = true;
        this.targetSpacingPixels = 0;
    }

    static get properties() {

        return {
            opened: {type: Boolean},

            position: {type: String, reflect: true},

            openOnClick: {type: Boolean, reflect: true},

            targetSpacingPixels: {type: Number, reflect: true}
        }

    }

    firstUpdated(_changedProperties) {
        this.overlay = this.shadowRoot.getElementById('overlay');
        this.targetElement = this.shadowRoot.getElementById('target').assignedNodes()[0];
        this.targetElement.addEventListener('click', (e) => !this.openOnClick ? e.stopPropagation() : this._changeOpenedState(!this.opened, e));

        this._boundSetPosition = this._setPosition.bind(this);
        this._boundOutsideClickListener = this._outsideClickListener.bind(this);
        this._boundKeydownListener = this._keydownListener.bind(this);
    }

    updated(changedProperties) {
        changedProperties.forEach((oldValue, propName) => {
            if (propName === 'opened') {
                this._openedChanged(this.opened, oldValue);
            }
        });
    }

    _openedChanged(opened, oldValue) {
        if (!!opened === !!oldValue) {
            return;
        }

        if (opened) {
            this._setPosition();
            this._addCloseListeners();
            if (this.position == null) {
                this._addPositionChangeListeners();
            }
        } else {
            this._removeCloseListeners();
            if (this.position == null) {
                this.removePositionChangeListeners();
            }
        }
    }

    removePositionChangeListeners() {
        window.removeEventListener('scroll', this._boundSetPosition, true);
        window.removeEventListener('resize', this._boundSetPosition, true);
    }

    _addPositionChangeListeners() {
        window.addEventListener('scroll', this._boundSetPosition, true);
        window.addEventListener('resize', this._boundSetPosition, true);
    }

    _removeCloseListeners() {
        document.removeEventListener('click', this._boundOutsideClickListener, true);
        document.removeEventListener('keydown', this._boundKeydownListener, true);
    }

    _addCloseListeners() {
        document.addEventListener('click', this._boundOutsideClickListener, true);
        document.addEventListener('keydown', this._boundKeydownListener, true);
    }

    _outsideClickListener(event) {
        // Support for nested popups
        // Check if this is the last opened
        if (!this.overlay._last) {
            return;
        }

        const eventPath = event.composedPath();

        if (eventPath.indexOf(this.targetElement) < 0 && eventPath.indexOf(this.overlay) < 0) {
            this._changeOpenedState(false, event);
        }
    }

    _keydownListener(event) {
        if (event.key === 'Escape' || event.key === 'Esc') {
            this._changeOpenedState(false, event);
        }
    }

    _changeOpenedState(opened, sourceEvent) {
        this.opened = opened;
        let evt = new CustomEvent('simple-popup-opened-changed', {bubbles: true, cancelable: true, detail: {sourceEvent: sourceEvent}});
        this.dispatchEvent(evt);
    }

    _setPosition() {
        let targetRect = this.targetElement.getBoundingClientRect();
        const overlayRect = this.overlay.getBoundingClientRect();

        switch (this.position) {
            case positions.TOP:
                this.overlay.style.top = (targetRect.top - overlayRect.height - this.targetSpacingPixels) + "px";
                this.overlay.style.left = targetRect.left + "px";
                break;
            case positions.BOTTOM:
                this.overlay.style.top = (targetRect.bottom + this.targetSpacingPixels) + "px";
                this.overlay.style.left = targetRect.left + "px";
                break;
            case positions.LEFT:
                this.overlay.style.top = targetRect.top + "px";
                this.overlay.style.left = (targetRect.left - overlayRect.width - this.targetSpacingPixels) + "px";
                break;
            case positions.RIGHT:
                this.overlay.style.top = targetRect.top + "px";
                this.overlay.style.left = (targetRect.right + this.targetSpacingPixels) + "px";
                break;
            case positions.BOTTOM_RIGHT:
                this.overlay.style.top = (targetRect.bottom + this.targetSpacingPixels) + "px";
                this.overlay.style.left = (targetRect.right - overlayRect.width) + "px";
                break;

            default:
                this._setDefaultDynamicPosition(targetRect, overlayRect);
        }
    }

    _setDefaultDynamicPosition(targetRect, overlayRect){
        this.alignedAbove = this._shouldAlignAbove(targetRect);

        this._translateX = targetRect.left - overlayRect.left + (this._translateX || 0);
        this._translateY = targetRect.top - overlayRect.top + (this._translateY || 0) +
            this._verticalOffset(overlayRect, targetRect);

        const _devicePixelRatio = window.devicePixelRatio || 1;
        this._translateX = Math.round(this._translateX * _devicePixelRatio) / _devicePixelRatio;
        this._translateY = Math.round(this._translateY * _devicePixelRatio) / _devicePixelRatio;
        this.overlay.style.transform = `translate3d(${this._translateX}px, ${this._translateY}px, 0)`;

        this.overlay.style.justifyContent = this.alignedAbove ? 'flex-end' : 'flex-start';
    }

    _verticalOffset(overlayRect, targetRect) {
        return this.alignedAbove ? -overlayRect.height : targetRect.height;
    }

    _shouldAlignAbove(targetRect) {
        const spaceBelow = (
            window.innerHeight -
            targetRect.bottom -
            Math.min(document.body.scrollTop, 0)
        ) / window.innerHeight;

        return spaceBelow < 0.30;
    }

    static get is() {
        return 'simple-popup';
    }
}

customElements.define(SimplePopup.is, SimplePopup);

registerStyles('simple-popup-overlay', css`
    :host {
        align-items: flex-start; 
        justify-content: flex-start; 
        right: auto; 
        bottom: auto; 
        position: absolute; 
    }
    
    [part="content"] {
        padding: 0;
      }
      
    *:focus {
      outline: none;
    }
    `);

class SimplePopupOverlay extends OverlayElement {

    static get is() {
        return 'simple-popup-overlay';
    }
}

customElements.define(SimplePopupOverlay.is, SimplePopupOverlay);